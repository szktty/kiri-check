import 'dart:collection';

import 'package:kiri_check/src/arbitrary.dart';
import 'package:kiri_check/src/arbitrary/top.dart';
import 'package:kiri_check/src/exception.dart';
import 'package:kiri_check/src/random.dart';

abstract class DeckArbitraries {
  static Arbitrary<Deck> deck() => DeckArbitrary();
}

final class DeckArbitrary extends ArbitraryBase<Deck> {
  DeckArbitrary();

  final Map<Deck, LinkedHashMap<ArbitraryInternal<dynamic>, dynamic>> _history =
      {};

  @override
  int get enumerableCount => 0;

  @override
  List<Deck>? get edgeCases => null;

  @override
  bool get isExhaustive => false;

  GenerationDeck _createGenerationDeck(
    RandomContext random, {
    required DeckGenerationMode mode,
  }) {
    final deck = GenerationDeck(this, random: random, mode: mode);
    _history[deck] = LinkedHashMap();
    return deck;
  }

  void _addDrew<T>(Deck deck, ArbitraryInternal<T> arbitrary, dynamic value) {
    _history[deck]![arbitrary] = value;
  }

  @override
  Deck getFirst(RandomContext random) =>
      _createGenerationDeck(random, mode: DeckGenerationMode.first);

  @override
  Deck generate(RandomContext random) =>
      _createGenerationDeck(random, mode: DeckGenerationMode.normal);

  @override
  Deck generateRandom(RandomContext random) =>
      _createGenerationDeck(random, mode: DeckGenerationMode.random);

  @override
  List<Deck> generateExhaustive() => throw PropertyException(
        'deck arbitrary does not support exhaustive generation',
      );

  @override
  ShrinkingDistance calculateDistance(Deck value) {
    final history = _history[value]!;
    final distance = ShrinkingDistance(0);
    for (final drew in history.entries) {
      final dimension = drew.key.calculateDistance(drew.value);
      distance.addDimension(dimension);
    }
    return distance;
  }

  // Shrinks the last used value.
  @override
  List<Deck> shrink(Deck value, ShrinkingDistance distance) {
    final deck = value as DeckBase;
    final history = _history[deck]!;

    final entries = history.entries.toList();
    final last = entries.last;
    final lastShrunk =
        last.key.shrink(last.value, distance.dimensions[history.length - 1]);

    final shrunkDecks = <Deck>[];
    for (var i = 0; i < lastShrunk.length; i++) {
      final shrunkToDraw = <dynamic>[];
      for (var j = 0; j < entries.length - 1; j++) {
        shrunkToDraw.add(entries[j].value);
      }
      shrunkToDraw.add(lastShrunk[i]);
      final shrunkDeck = ShrinkingDeck(
        this,
        random: deck.random,
        mode: deck.mode,
        shrunk: shrunkToDraw,
      );
      shrunkDecks.add(shrunkDeck);
      _history[shrunkDeck] = LinkedHashMap();
    }
    return shrunkDecks;
  }

  @override
  String describeExample(Deck example) {
    final history = _history[example]!;
    final drews = history.entries
        .map((e) => '${e.key.runtimeType}: ${e.key.describeExample(e.value)}');
    return '{${drews.join(', ')}}';
  }
}

enum DeckGenerationMode {
  first,
  normal,
  random,
}

/// An object generated by [deck] that can select arbitraries dynamically
/// to generate values.
// ignore: one_member_abstracts
abstract class Deck {
  /// Generates a value using the given arbitrary.
  T draw<T>(Arbitrary<T> arbitrary);
}

abstract class DeckBase extends Deck {
  DeckBase(
    this.deckArbitrary, {
    required this.random,
    required this.mode,
  });

  final DeckArbitrary deckArbitrary;
  final DeckGenerationMode mode;
  final RandomContext random;

  T generate<T>(ArbitraryInternal<T> arbitrary) {
    T value;
    switch (mode) {
      case DeckGenerationMode.first:
        value = arbitrary.getFirst(random);
      case DeckGenerationMode.normal:
        value = arbitrary.generate(random);
      case DeckGenerationMode.random:
        value = arbitrary.generateRandom(random);
    }

    deckArbitrary._addDrew(this, arbitrary, value);
    return value;
  }
}

final class GenerationDeck extends DeckBase {
  GenerationDeck(
    super.deckArbitrary, {
    required super.random,
    required super.mode,
  });

  @override
  T draw<T>(Arbitrary<T> arbitrary) =>
      generate(arbitrary as ArbitraryInternal<T>);
}

final class ShrinkingDeck extends DeckBase {
  ShrinkingDeck(
    super.deckArbitrary, {
    required super.random,
    required super.mode,
    required this.shrunk,
  }) {
    _queue = Queue.from(shrunk);
  }

  final List<dynamic> shrunk;
  late final Queue<dynamic> _queue;

  LinkedHashMap<ArbitraryInternal<dynamic>, dynamic>? get falsifyingExamples =>
      LinkedHashMap.fromEntries(_falsifyingExamples.entries);

  final LinkedHashMap<ArbitraryInternal<dynamic>, dynamic> _falsifyingExamples =
      LinkedHashMap();

  @override
  T draw<T>(Arbitrary<T> arbitrary) {
    final arbitrary1 = arbitrary as ArbitraryInternal<T>;
    T value;
    if (_queue.isEmpty) {
      value = generate(arbitrary1);
    } else {
      value = _queue.removeFirst() as T;
      deckArbitrary._addDrew(this, arbitrary1, value);
    }
    _falsifyingExamples[arbitrary] = value;
    return value;
  }
}

# Stateful testing

## What should be tested

- 何をテストするのか
- kiri-checkのステートフルテストでは、抽象モデルと実システムの状態変化を照合する
- 抽象モデルとは、実システムのあるべき振る舞いを表現したもの
- ランダムなコマンドにより抽象モデルと実システムの状態を変化させ、実システムの状態がモデルと比較して妥当であるかを検証する
- そのため、抽象モデルの実装は正確かつシンプルにすべき

- 以下保留
- kiri-checkにおけるステートフルテストは、有限状態機械(FSM)に対する検証である
- 他のライブラリでは、ステートフルテストはモデルベースやルールベースとも呼ばれることがある
- kiri-checkのステートフルテストはモデル検査とは異なる。モデルのロジックの妥当性を検証するものではなく、状態変化処理が正しく実装されているかどうかを検証する。モデルの妥当性を検証したいのであれば、形式仕様記述言語などの他の方法を推奨する

- 状態はコマンドの実行によって自身の内容を変更する。遷移するとも言う
- ステートフルテストは、ランダムに選択されたコマンド実行前後の状態に対して検証を行う
- 図: ステートフルテストのフローチャート

- 3段階のフェーズ
- コマンド選択フェーズ
  - 実行対象のコマンドを生成する
  - 事前条件が偽でも失敗にはならず、コマンドは実行対象にならない
- コマンド実行フェーズ
  - 事前条件が偽の場合、失敗扱いになる
  - シュリンクを開始する
- シュリンクフェーズ
  - 詳細はシュリンクの項を参照

- 以下はQuickstartを参照してもらう
- 例として、シンプルなカウンターを考える
- ライブラリの使い方の例示なので、今回は実システムは用意しない。コマンドの実行前後のモデルの状態を比較するだけとする
- 実システムはNullとする
- 実際のテストコードはQuickstartを参照
- カウンターは0から始まり、インクリメント、デクリメント、リセットの3つのコマンドを受け付ける
- テストを実行すると、これらのコマンドがランダムに選択され、一定の回数が実行される。
- フローチャート
- 様々なコマンドがテストされることで、特定のコマンドの組み合わせや実行順序に関係するバグを発見できる
- エラーがあると、シュリンクによってコマンド列が切り詰められ、最小のエラーを見つける
 


## Shrinking

- エラーが発生した場合、コマンド列を縮小する
- 部分列、削除、値の縮小
- 縮小されたコマンド列が最小のエラーを示す
